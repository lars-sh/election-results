<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetricsFiles.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Election Results Core</a> &gt; <a href="index.source.html" class="el_package">de.larssh.election.germany.schleswigholstein.local.file</a> &gt; <span class="el_source">MetricsFiles.java</span></div><h1>MetricsFiles.java</h1><pre class="source lang-java linenums">// Generated by delombok at Thu Feb 23 22:08:00 UTC 2023
package de.larssh.election.germany.schleswigholstein.local.file;

import static java.util.stream.Collectors.joining;
import java.io.IOException;
import java.io.OutputStream;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiConsumer;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.FillPatternType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.AreaReference;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.ss.util.CellUtil;
import org.apache.poi.ss.util.SheetUtil;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFColor;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFTable;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTCell;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTTable;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.CTTableColumn;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.STCellType;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.STTotalsRowFunction;
import de.larssh.election.germany.schleswigholstein.Color;
import de.larssh.election.germany.schleswigholstein.District;
import de.larssh.election.germany.schleswigholstein.Keys;
import de.larssh.election.germany.schleswigholstein.Party;
import de.larssh.election.germany.schleswigholstein.local.LocalElectionResult;
import de.larssh.election.germany.schleswigholstein.local.LocalNomination;
import de.larssh.election.germany.schleswigholstein.local.LocalNominationResult;
import de.larssh.election.germany.schleswigholstein.local.LocalNominationResultType;
import de.larssh.election.germany.schleswigholstein.local.LocalPollingStation;
import de.larssh.utils.OptionalInts;
import de.larssh.utils.annotations.PackagePrivate;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * This class contains helper methods to write an Excel spreadsheet (XLSX) with
 * metrics of an election result.
 */
@SuppressWarnings(&quot;PMD.ExcessiveImports&quot;)
public final class MetricsFiles {
	/**
	 * Formats and writes {@code result} to {@code outputStream}.
	 *
	 * @param result       the election result to to write
	 * @param outputStream the metrics file output stream
	 * @throws IOException on IO error
	 */
	public static void write(final LocalElectionResult result, final OutputStream outputStream) throws IOException {
<span class="nc" id="L66">		new MetricsFileWriter(result, outputStream).write();</span>
<span class="nc" id="L67">	}</span>


	/**
	 * This class writes metrics of a {@link LocalElectionResult} to an Excel
	 * spreadsheet (XLSX).
	 */
	@SuppressWarnings({&quot;checkstyle:MultipleStringLiterals&quot;, &quot;PMD.AvoidDuplicateLiterals&quot;})
	private static class MetricsFileWriter {
		/**
		 * Width of the auto filter control in Excel, calculated using the difference of
		 * a cell without and with auto filter
		 */
		private static final int AUTO_FILTER_WIDTH = 563;
		/**
		 * Width of one character
		 */
		private static final int CHARACTER_WIDTH = 256;
		/**
		 * The maximum width of a column
		 */
		private static final int COLUMN_MAX_WIDTH = 255 * CHARACTER_WIDTH;
		/**
		 * Excel data format for percentage values
		 */
		private static final String DATA_FORMAT_PERCENTAGE = &quot;0.0%&quot;;
		/**
		 * Excel data format for differences between two percentage values, showing the
		 * plus sign in case of a positive value
		 */
		private static final String DATA_FORMAT_PERCENTAGE_WITH_SIGN = &quot;\\+0.0%;\\-0.0%;0.0%&quot;;
		/**
		 * Excel data format for any number with any number of decimal places
		 */
<span class="nc" id="L101">		private static final ThreadLocal&lt;NumberFormat&gt; DECIMAL_FORMAT = ThreadLocal.withInitial(() -&gt; {</span>
<span class="nc" id="L102">			final DecimalFormat format = new DecimalFormat(&quot;0.#&quot;, DecimalFormatSymbols.getInstance(Locale.ROOT));</span>
<span class="nc" id="L103">			format.setMaximumFractionDigits(Integer.MAX_VALUE);</span>
<span class="nc" id="L104">			return format;</span>
		});

		/**
		 * Appends a row to {@code sheet} below the currently last row.
		 *
		 * @param sheet the sheet to modify
		 * @return the created row
		 */
		private static Row appendRow(final Sheet sheet) {
<span class="nc" id="L114">			return CellUtil.getRow(sheet.getLastRowNum() + 1, sheet);</span>
		}

		/**
		 * Creates a table with auto filter, default style and {@ode name}, spanning all
		 * curently available cells.
		 *
		 * @param sheet the sheet to modify
		 * @param name  the table name
		 * @return the created table
		 */
		private static XSSFTable createTable(final Sheet sheet, final String name) {
<span class="nc" id="L126">			final XSSFTable table = ((XSSFSheet) sheet).createTable(new AreaReference(new CellReference(0, 0), new CellReference(sheet.getLastRowNum(), CellUtil.getRow(0, sheet).getLastCellNum() - 1), SpreadsheetVersion.EXCEL2007));</span>
<span class="nc" id="L127">			table.setName(name);</span>
<span class="nc" id="L128">			table.setDisplayName(name);</span>
<span class="nc" id="L129">			table.setStyleName(&quot;TableStyleLight1&quot;);</span>
<span class="nc" id="L130">			table.getCTTable().addNewAutoFilter();</span>
<span class="nc" id="L131">			return table;</span>
		}

		/**
		 * Converts a {@link LocalNominationResultType} to a display value.
		 *
		 * @param type the type to convert
		 * @return the type's display value
		 */
		private static String getDisplayValue(final LocalNominationResultType type) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">			if (type == LocalNominationResultType.DIRECT) {</span>
<span class="nc" id="L142">				return &quot;Direkt&quot;;</span>
			}
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if (type == LocalNominationResultType.DIRECT_DRAW) {</span>
<span class="nc" id="L145">				return &quot;Los&quot;;</span>
			}
<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (type == LocalNominationResultType.DIRECT_BALANCE_SEAT) {</span>
<span class="nc" id="L148">				return &quot;Mehrsitz&quot;;</span>
			}
<span class="nc bnc" id="L150" title="All 2 branches missed.">			if (type == LocalNominationResultType.LIST) {</span>
<span class="nc" id="L151">				return &quot;Liste&quot;;</span>
			}
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (type == LocalNominationResultType.LIST_DRAW) {</span>
<span class="nc" id="L154">				return &quot;Los&quot;;</span>
			}
<span class="nc bnc" id="L156" title="All 2 branches missed.">			if (type == LocalNominationResultType.LIST_OVERHANG_SEAT) {</span>
<span class="nc" id="L157">				return &quot;Überhang&quot;;</span>
			}
<span class="nc" id="L159">			return &quot;&quot;;</span>
		}

		/**
		 * Sets a numeric {@code value} for {@code cell}.
		 *
		 * &lt;p&gt;
		 * This method allows setting e.g. precise {@link java.math.BigDecimal} values,
		 * but does not permit infinite and {@code NaN} values.
		 *
		 * @param cell  the cell to modify
		 * @param value the value to set
		 */
		private static void setCellValue(final Cell cell, final Number value) {
<span class="nc" id="L173">			final CTCell ctCell = ((XSSFCell) cell).getCTCell();</span>
<span class="nc" id="L174">			ctCell.setT(STCellType.N);</span>
<span class="nc" id="L175">			ctCell.setV(DECIMAL_FORMAT.get().format(value));</span>
<span class="nc" id="L176">		}</span>

		/**
		 * Election Result to create metrics of
		 *
		 * @return the election result to create metrics of
		 */
		private final LocalElectionResult result;
		/**
		 * Metrics file output stream
		 *
		 * @return the metrics file output stream
		 */
		private final OutputStream outputStream;
		/**
		 * Cache to simplify reusing {@link CellStyle} instances
		 */
<span class="nc" id="L193">		private final Map&lt;String, CellStyle&gt; cellStyleCache = new HashMap&lt;&gt;();</span>
		/**
		 * The Excel data format for Sainte Laguë values, decimal places being derived
		 * from {@link LocalElectionResult#getSainteLagueScale()}.
		 */
		private final String dataFormatSainteLague;

		/**
		 * This class writes metrics of a {@link LocalElectionResult} to an Excel
		 * spreadsheet (XLSX).
		 *
		 * @param result       the {@link LocalElectionResult} to create metrics of
		 * @param outputStream the {@link OutputStream} to write to
		 */
		@PackagePrivate
<span class="nc" id="L208">		MetricsFileWriter(final LocalElectionResult result, final OutputStream outputStream) {</span>
<span class="nc" id="L209">			this.result = result;</span>
<span class="nc" id="L210">			this.outputStream = outputStream;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">			dataFormatSainteLague = result.getSainteLagueScale() == 0 ? &quot;0&quot; : String.format(&quot;0.%0&quot; + result.getSainteLagueScale() + &quot;d&quot;, 0);</span>
<span class="nc" id="L212">		}</span>

		/**
		 * Appends a cell to {@code row} after the currently last cell.
		 *
		 * @param &lt;T&gt;        the value's data type
		 * @param row        the row to modify
		 * @param party      the {@link Party} to be used for coloring or empty
		 * @param dataFormat the Excel data format to set or empty
		 * @param setValue   a method to set the value to the created cell
		 * @param value      the value to set or empty
		 * @return the created cell
		 */
		@SuppressWarnings({&quot;checkstyle:SuppressWarnings&quot;, &quot;resource&quot;})
		private &lt;T&gt; Cell appendCell(final Row row, final Optional&lt;Party&gt; party, final Optional&lt;String&gt; dataFormat, final BiConsumer&lt;Cell, T&gt; setValue, final Optional&lt;T&gt; value) {
<span class="nc" id="L227">			final Cell cell = CellUtil.getCell(row, Math.max(0, row.getLastCellNum()));</span>
<span class="nc" id="L228">			getCellStyle(row.getSheet().getWorkbook(), party, dataFormat).ifPresent(cell::setCellStyle);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">			if (value.isPresent()) {</span>
<span class="nc" id="L230">				setValue.accept(cell, value.get());</span>
			}
<span class="nc" id="L232">			return cell;</span>
		}

		/**
		 * Appends a cell with {@code formula} to {@code row} after the currently last
		 * cell.
		 *
		 * @param row     the row to modify
		 * @param party   the {@link Party} to be used for coloring or empty
		 * @param formula the formula to set
		 * @return the created cell
		 */
		private Cell appendFormula(final Row row, final Optional&lt;Party&gt; party, final String formula) {
<span class="nc" id="L245">			return appendCell(row, party, Optional.empty(), Cell::setCellFormula, Optional.of(formula));</span>
		}

		/**
		 * Appends a cell with {@code formula} to {@code row} after the currently last
		 * cell.
		 *
		 * @param row        the row to modify
		 * @param party      the {@link Party} to be used for coloring or empty
		 * @param dataFormat the Excel data format to set or empty
		 * @param formula    the formula to set
		 * @return the created cell
		 */
		private Cell appendFormula(final Row row, final Optional&lt;Party&gt; party, final String dataFormat, final String formula) {
<span class="nc" id="L259">			return appendCell(row, party, Optional.of(dataFormat), Cell::setCellFormula, Optional.of(formula));</span>
		}

		/**
		 * Appends a cell with numeric {@code value} to {@code row} after the currently
		 * last cell.
		 *
		 * @param row   the row to modify
		 * @param party the {@link Party} to be used for coloring or empty
		 * @param value the value to set or empty
		 * @return the created cell
		 */
		private Cell appendNumber(final Row row, final Optional&lt;Party&gt; party, final Optional&lt;? extends Number&gt; value) {
<span class="nc" id="L272">			return appendCell(row, party, Optional.empty(), MetricsFileWriter::setCellValue, value);</span>
		}

		/**
		 * Appends a cell with string {@code value} to {@code row} after the currently
		 * last cell.
		 *
		 * @param row   the row to modify
		 * @param party the {@link Party} to be used for coloring or empty
		 * @param value the value to set or empty
		 * @return the created cell
		 */
		private Cell appendString(final Row row, final Optional&lt;Party&gt; party, final String value) {
<span class="nc" id="L285">			return appendCell(row, party, Optional.empty(), Cell::setCellValue, Optional.of(value));</span>
		}

		/**
		 * Appends cells with string {@code values} to {@code row} after the currently
		 * last cell.
		 *
		 * @param row    the row to modify
		 * @param values the values to set
		 */
		private void appendStrings(final Row row, final String... values) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">			for (final String value : values) {</span>
<span class="nc" id="L297">				appendString(row, Optional.empty(), value);</span>
			}
<span class="nc" id="L299">		}</span>

		/**
		 * Returns a {@link CellStyle} instance with the coloring of {@code party} and
		 * {@code dataFormat}. Cell styles are cached and reused.
		 *
		 * @param workbook   the current workbook
		 * @param party      the {@link Party} to be used for coloring or empty
		 * @param dataFormat the Excel data format to set or empty
		 * @return the {@link CellStyle} instance with the coloring of {@code party} and
		 *         {@code dataFormat}
		 */
		private Optional&lt;CellStyle&gt; getCellStyle(final Workbook workbook, final Optional&lt;Party&gt; party, final Optional&lt;String&gt; dataFormat) {
<span class="nc bnc" id="L312" title="All 4 branches missed.">			if (!party.isPresent() &amp;&amp; !dataFormat.isPresent()) {</span>
<span class="nc" id="L313">				return Optional.empty();</span>
			}
<span class="nc" id="L315">			final String key = Keys.escape(party.map(Party::getKey).orElse(&quot;&quot;), &quot;, &quot;, dataFormat.orElse(&quot;&quot;), &quot;&quot;);</span>
<span class="nc" id="L316">			return Optional.of(cellStyleCache.computeIfAbsent(key, k -&gt; {</span>
<span class="nc" id="L317">				final CellStyle cellStyle = workbook.createCellStyle();</span>
<span class="nc" id="L318">				party.ifPresent(p -&gt; {</span>
<span class="nc" id="L319">					cellStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span>
<span class="nc" id="L320">					final Color backgroundColor = p.getBackgroundColor();</span>
<span class="nc" id="L321">					cellStyle.setFillForegroundColor(new XSSFColor(new byte[] {(byte) backgroundColor.getAlphaAsByte(), (byte) backgroundColor.getRedAsByte(), (byte) backgroundColor.getGreenAsByte(), (byte) backgroundColor.getBlueAsByte()}));</span>
<span class="nc" id="L322">					final Color fontColor = p.getFontColor();</span>
<span class="nc" id="L323">					final XSSFFont font = (XSSFFont) workbook.createFont();</span>
<span class="nc" id="L324">					font.setColor(new XSSFColor(new byte[] {(byte) fontColor.getAlphaAsByte(), (byte) fontColor.getRedAsByte(), (byte) fontColor.getGreenAsByte(), (byte) fontColor.getBlueAsByte()}));</span>
<span class="nc" id="L325">					cellStyle.setFont(font);</span>
<span class="nc" id="L326">				});</span>
<span class="nc" id="L327">				dataFormat.ifPresent(f -&gt; cellStyle.setDataFormat(workbook.createDataFormat().getFormat(f)));</span>
<span class="nc" id="L328">				return cellStyle;</span>
			}));
		}

		/**
		 * Formats and writes {@link #result} to {@link #writer}.
		 *
		 * @throws IOException on IO error
		 */
		@PackagePrivate
		void write() throws IOException {
<span class="nc" id="L339">			try (XSSFWorkbook workbook = new XSSFWorkbook()) {</span>
<span class="nc" id="L340">				workbook.setCellFormulaValidation(false);</span>
<span class="nc" id="L341">				writeOverview(workbook.createSheet(&quot;Übersicht&quot;));</span>
<span class="nc" id="L342">				writeParties(workbook.createSheet(&quot;Gruppierungen&quot;));</span>
<span class="nc" id="L343">				writeBlockVotes(workbook.createSheet(&quot;Blockstimmen&quot;));</span>
<span class="nc" id="L344">				writeNominations(workbook.createSheet(&quot;Kandidierende&quot;));</span>
				// Auto Size Columns
<span class="nc" id="L346">				workbook.sheetIterator().forEachRemaining(sheet -&gt; {</span>
<span class="nc" id="L347">					final int numberOfColumns = sheet.getRow(0).getLastCellNum();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">					for (int columnIndex = 0; columnIndex &lt; numberOfColumns; columnIndex += 1) {</span>
<span class="nc" id="L349">						sheet.autoSizeColumn(columnIndex);</span>
						// Add the width of the auto filter
<span class="nc" id="L351">						final double widthOfHeader = SheetUtil.getColumnWidth(sheet, columnIndex, false, 0, 0);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">						if (widthOfHeader != -1) {</span>
<span class="nc" id="L353">							final int intWidth = (int) Math.round(Math.min(CHARACTER_WIDTH * widthOfHeader + AUTO_FILTER_WIDTH, COLUMN_MAX_WIDTH));</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">							if (intWidth &gt; sheet.getColumnWidth(columnIndex)) {</span>
<span class="nc" id="L355">								sheet.setColumnWidth(columnIndex, intWidth);</span>
							}
						}
					}
<span class="nc" id="L359">				});</span>
<span class="nc" id="L360">				workbook.write(outputStream);</span>
			}
<span class="nc" id="L362">		}</span>

		/**
		 * Adds the sheet &quot;Übersicht&quot;
		 *
		 * @param sheet the sheet to write to
		 */
		private void writeOverview(final Sheet sheet) {
			// Header
<span class="nc" id="L371">			appendStrings(appendRow(sheet), &quot;Wahlbezirk&quot;, &quot;Wahlberechtigte&quot;, &quot;Stimmzettel&quot;, &quot;Wahlbeteiligung&quot;, &quot;ausgezählt&quot;, &quot;ausgezählt %&quot;, &quot;ungültig&quot;);</span>
			// Content
<span class="nc bnc" id="L373" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
<span class="nc" id="L374">				writeOverviewOfDistrict(appendRow(sheet), pollingStation);</span>
<span class="nc" id="L375">			}</span>
			// Table
<span class="nc" id="L377">			sheet.createFreezePane(1, 0);</span>
<span class="nc" id="L378">			final XSSFTable table = createTable(sheet, &quot;Übersicht&quot;);</span>
<span class="nc" id="L379">			table.getCTTable().getTableStyleInfo().setShowFirstColumn(true);</span>
<span class="nc" id="L380">			table.getCTTable().getTableStyleInfo().setShowRowStripes(true);</span>
			// Totals Row
<span class="nc" id="L382">			table.setDataRowCount(table.getDataRowCount() + 1);</span>
<span class="nc" id="L383">			writeOverviewTotalsRow(appendRow(sheet), table.getCTTable());</span>
<span class="nc" id="L384">		}</span>

		/**
		 * Adds a row with district metrics to the sheet &quot;Übersicht&quot;
		 *
		 * @param row      the row to write to
		 * @param district the district
		 */
		@SuppressFBWarnings(value = &quot;OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED&quot;, justification = &quot;need to match generics&quot;)
		private void writeOverviewOfDistrict(final Row row, final District&lt;?&gt; district) {
			// Wahlbezirk
<span class="nc" id="L395">			appendStrings(row, district.getName());</span>
			// Wahlberechtigte
<span class="nc" id="L397">			appendNumber(row, Optional.empty(), OptionalInts.boxed(result.getElection().getNumberOfEligibleVoters(district)));</span>
			// Stimmzettel
<span class="nc" id="L399">			appendNumber(row, Optional.empty(), OptionalInts.boxed(result.getNumberOfAllBallots(district)));</span>
			// Wahlbeteiligung
<span class="nc" id="L401">			appendFormula(row, Optional.empty(), DATA_FORMAT_PERCENTAGE, &quot;Übersicht[Stimmzettel] / Übersicht[Wahlberechtigte]&quot;);</span>
			// ausgezählt
<span class="nc" id="L403">			appendNumber(row, Optional.empty(), Optional.of(result.getBallots(district).size()));</span>
			// ausgezählt %
<span class="nc" id="L405">			appendFormula(row, Optional.empty(), DATA_FORMAT_PERCENTAGE, &quot;Übersicht[ausgezählt] / Übersicht[Stimmzettel]&quot;);</span>
			// ungültig
<span class="nc" id="L407">			appendNumber(row, Optional.empty(), Optional.of(result.getNumberOfInvalidBallots(district)));</span>
<span class="nc" id="L408">		}</span>

		/**
		 * Adds a total row to the sheet &quot;Übersicht&quot;
		 *
		 * @param row   the row to write to
		 * @param table the Excel table to update
		 */
		private void writeOverviewTotalsRow(final Row row, final CTTable table) {
<span class="nc" id="L417">			table.setTotalsRowCount(1);</span>
<span class="nc" id="L418">			final Iterator&lt;CTTableColumn&gt; columns = table.getTableColumns().getTableColumnList().iterator();</span>
			// Wahlbezirk
<span class="nc" id="L420">			columns.next().setTotalsRowLabel(&quot;Gesamt&quot;);</span>
<span class="nc" id="L421">			appendStrings(row, &quot;Gesamt&quot;);</span>
			// Wahlberechtigte
<span class="nc" id="L423">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L424">			appendFormula(row, Optional.empty(), &quot;SUM(Übersicht[Wahlberechtigte])&quot;);</span>
			// Stimmzettel
<span class="nc" id="L426">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L427">			appendFormula(row, Optional.empty(), &quot;SUM(Übersicht[Stimmzettel])&quot;);</span>
			// Wahlbeteiligung
<span class="nc" id="L429">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L430">			appendFormula(row, Optional.empty(), DATA_FORMAT_PERCENTAGE, &quot;Übersicht[[#Totals],[Stimmzettel]] / Übersicht[[#Totals],[Wahlberechtigte]]&quot;);</span>
			// ausgezählt
<span class="nc" id="L432">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L433">			appendFormula(row, Optional.empty(), &quot;SUM(Übersicht[ausgezählt])&quot;);</span>
			// ausgezählt %
<span class="nc" id="L435">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L436">			appendFormula(row, Optional.empty(), DATA_FORMAT_PERCENTAGE, &quot;Übersicht[[#Totals],[ausgezählt]] / Übersicht[[#Totals],[Stimmzettel]]&quot;);</span>
			// ungültig
<span class="nc" id="L438">			columns.next().setTotalsRowFunction(STTotalsRowFunction.CUSTOM);</span>
<span class="nc" id="L439">			appendFormula(row, Optional.empty(), &quot;SUM(Übersicht[ungültig])&quot;);</span>
<span class="nc" id="L440">		}</span>

		/**
		 * Adds the sheet &quot;Gruppierungen&quot;
		 *
		 * @param sheet the sheet to write to
		 */
		private void writeParties(final Sheet sheet) {
			// Header
<span class="nc" id="L449">			final Row row = appendRow(sheet);</span>
<span class="nc" id="L450">			appendStrings(row, &quot;Gruppierung&quot;);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
<span class="nc" id="L452">				appendStrings(row, pollingStation.getName(), pollingStation.getName() + &quot; %&quot;);</span>
<span class="nc" id="L453">			}</span>
<span class="nc" id="L454">			appendStrings(row, &quot;Gesamt&quot;, &quot;Gesamt %&quot;, &quot;Sitze&quot;);</span>
			// Content
<span class="nc bnc" id="L456" title="All 2 branches missed.">			for (final Party party : result.getPartyResults().keySet()) {</span>
<span class="nc" id="L457">				writeParty(appendRow(sheet), party);</span>
<span class="nc" id="L458">			}</span>
			// Table
<span class="nc" id="L460">			sheet.createFreezePane(1, 0);</span>
<span class="nc" id="L461">			final XSSFTable table = createTable(sheet, &quot;Gruppierungen&quot;);</span>
<span class="nc" id="L462">			table.getCTTable().getTableStyleInfo().setShowFirstColumn(true);</span>
<span class="nc" id="L463">		}</span>

		/**
		 * Adds a row with party metrics to the sheet &quot;Gruppierungen&quot;
		 *
		 * @param row   the row to write to
		 * @param party the party
		 */
		@SuppressFBWarnings(value = &quot;OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED&quot;, justification = &quot;need to match generics&quot;)
		private void writeParty(final Row row, final Party party) {
<span class="nc" id="L473">			final Optional&lt;Party&gt; optionalParty = Optional.of(party);</span>
			// Gruppierung
<span class="nc" id="L475">			appendString(row, optionalParty, party.getShortName());</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
				// Stimmen
<span class="nc" id="L478">				appendNumber(row, optionalParty, Optional.of(result.filterByDistrict(pollingStation).getPartyResults().get(party).getNumberOfVotes()));</span>
				// Stimmen %
<span class="nc" id="L480">				appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE, &quot;Gruppierungen[[#This Row],[&quot; + pollingStation.getName() + &quot;]] / SUM(Gruppierungen[&quot; + pollingStation.getName() + &quot;])&quot;);</span>
<span class="nc" id="L481">			}</span>
			// Gesamt
<span class="nc" id="L483">			appendFormula(row, optionalParty, result.getElection().getPollingStations().stream().map(LocalPollingStation::getName).collect(joining(&quot;] + Gruppierungen[&quot;, &quot;Gruppierungen[&quot;, &quot;]&quot;)));</span>
			// Gesamt %
<span class="nc" id="L485">			appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE, &quot;Gruppierungen[[#This Row],[Gesamt]] / SUM(Gruppierungen[Gesamt])&quot;);</span>
			// Sitze
<span class="nc" id="L487">			appendFormula(row, optionalParty, &quot;COUNTIFS(Kandidierende[Gruppierung], Gruppierungen[[#This Row],[Gruppierung]], Kandidierende[Mandat], \&quot;&lt;&gt;\&quot;)&quot;);</span>
<span class="nc" id="L488">		}</span>

		/**
		 * Adds the sheet &quot;Blockstimmen&quot;
		 *
		 * @param sheet the sheet to write to
		 */
		private void writeBlockVotes(final Sheet sheet) {
			// Header
<span class="nc" id="L497">			final Row row = appendRow(sheet);</span>
<span class="nc" id="L498">			appendStrings(row, &quot;Gruppierung&quot;);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
<span class="nc" id="L500">				appendStrings(row, pollingStation.getName(), pollingStation.getName() + &quot; %&quot;, pollingStation.getName() + &quot; ±%&quot;);</span>
<span class="nc" id="L501">			}</span>
<span class="nc" id="L502">			appendStrings(row, &quot;Gesamt&quot;, &quot;Gesamt %&quot;, &quot;Gesamt ±%&quot;);</span>
			// Content
<span class="nc bnc" id="L504" title="All 2 branches missed.">			for (final Party party : result.getPartyResults().keySet()) {</span>
<span class="nc" id="L505">				writeBlockVotesOfParty(appendRow(sheet), party);</span>
<span class="nc" id="L506">			}</span>
			// Table
<span class="nc" id="L508">			sheet.createFreezePane(1, 0);</span>
<span class="nc" id="L509">			final XSSFTable table = createTable(sheet, &quot;Blockstimmen&quot;);</span>
<span class="nc" id="L510">			table.getCTTable().getTableStyleInfo().setShowFirstColumn(true);</span>
<span class="nc" id="L511">		}</span>

		/**
		 * Adds a row with block vote metrics of {@code party} to the sheet
		 * &quot;Blockstimmen&quot;
		 *
		 * @param row   the row to write to
		 * @param party the party
		 */
		@SuppressFBWarnings(value = &quot;OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED&quot;, justification = &quot;need to match generics&quot;)
		private void writeBlockVotesOfParty(final Row row, final Party party) {
<span class="nc" id="L522">			final Optional&lt;Party&gt; optionalParty = Optional.of(party);</span>
			// Gruppierung
<span class="nc" id="L524">			appendString(row, optionalParty, party.getShortName());</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
				// Stimmen
<span class="nc" id="L527">				appendNumber(row, optionalParty, Optional.of(result.filterByDistrict(pollingStation).getPartyResults().get(party).getNumberOfBlockVotings()));</span>
				// Stimmen %
<span class="nc" id="L529">				appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE, &quot;Blockstimmen[[#This Row],[&quot; + pollingStation.getName() + &quot;]] / SUM(Blockstimmen[&quot; + pollingStation.getName() + &quot;])&quot;);</span>
				// Stimmen ±%
<span class="nc" id="L531">				appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE_WITH_SIGN, &quot;Blockstimmen[&quot; + pollingStation.getName() + &quot; %] - INDEX(Gruppierungen[&quot; + pollingStation.getName() + &quot; %], MATCH(Blockstimmen[Gruppierung], Gruppierungen[Gruppierung], 0))&quot;);</span>
<span class="nc" id="L532">			}</span>
			// Gesamt
<span class="nc" id="L534">			appendFormula(row, optionalParty, result.getElection().getPollingStations().stream().map(LocalPollingStation::getName).collect(joining(&quot;] + Blockstimmen[&quot;, &quot;Blockstimmen[&quot;, &quot;]&quot;)));</span>
			// Gesamt %
<span class="nc" id="L536">			appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE, &quot;Blockstimmen[[#This Row],[Gesamt]] / SUM(Blockstimmen[Gesamt])&quot;);</span>
			// Gesamt ±%
<span class="nc" id="L538">			appendFormula(row, optionalParty, DATA_FORMAT_PERCENTAGE_WITH_SIGN, &quot;Blockstimmen[Gesamt %] - INDEX(Gruppierungen[Gesamt %], MATCH(Blockstimmen[Gruppierung], Gruppierungen[Gruppierung], 0))&quot;);</span>
<span class="nc" id="L539">		}</span>

		/**
		 * Adds the sheet &quot;Kandidierende&quot;
		 *
		 * @param sheet the sheet to write to
		 */
		private void writeNominations(final Sheet sheet) {
			// Header
<span class="nc" id="L548">			final Row row = appendRow(sheet);</span>
<span class="nc" id="L549">			appendStrings(row, &quot;#&quot;, &quot;Gruppierung&quot;, &quot;Nachname&quot;, &quot;Vorname&quot;);</span>
<span class="nc" id="L550">			final int freezeColumn = row.getLastCellNum();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
<span class="nc" id="L552">				appendStrings(row, pollingStation.getName());</span>
<span class="nc" id="L553">			}</span>
<span class="nc" id="L554">			appendStrings(row, &quot;Gesamt&quot;, &quot;Sainte-Laguë-Wert&quot;, &quot;Mandat&quot;);</span>
			// Content
<span class="nc bnc" id="L556" title="All 2 branches missed.">			for (final LocalNominationResult nominationResult : result.getNominationResults().values()) {</span>
<span class="nc" id="L557">				writeNomination(appendRow(sheet), nominationResult);</span>
<span class="nc" id="L558">			}</span>
			// Table
<span class="nc" id="L560">			sheet.createFreezePane(freezeColumn, 0);</span>
<span class="nc" id="L561">			createTable(sheet, &quot;Kandidierende&quot;);</span>
<span class="nc" id="L562">		}</span>

		/**
		 * Adds a row with nomination metrics to the sheet &quot;Kandidierende&quot;
		 *
		 * @param row              the row to write to
		 * @param nominationResult the nomination's results
		 */
		@SuppressFBWarnings(value = &quot;OI_OPTIONAL_ISSUES_PRIMITIVE_VARIANT_PREFERRED&quot;, justification = &quot;need to match generics&quot;)
		private void writeNomination(final Row row, final LocalNominationResult nominationResult) {
<span class="nc" id="L572">			final LocalNomination nomination = nominationResult.getNomination();</span>
<span class="nc" id="L573">			final Optional&lt;Party&gt; party = nomination.getParty();</span>
			// #
<span class="nc" id="L575">			appendNumber(row, party, nomination.getParty().map(p -&gt; new ArrayList&lt;&gt;(result.getElection().getNominations(p)).indexOf(nomination) + 1));</span>
			// Gruppierung
<span class="nc" id="L577">			appendCell(row, party, Optional.empty(), Cell::setCellValue, party.map(Party::getShortName));</span>
			// Nachname
<span class="nc" id="L579">			appendString(row, party, nomination.getPerson().getFamilyName());</span>
			// Vorname
<span class="nc" id="L581">			appendString(row, party, nomination.getPerson().getGivenName());</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			for (final LocalPollingStation pollingStation : result.getElection().getPollingStations()) {</span>
				// Stimmen
<span class="nc" id="L584">				appendNumber(row, party, Optional.of(result.filterByDistrict(pollingStation).getNominationResults().get(nomination).getNumberOfVotes()));</span>
<span class="nc" id="L585">			}</span>
			// Gesamt
<span class="nc" id="L587">			appendFormula(row, party, result.getElection().getPollingStations().stream().map(LocalPollingStation::getName).collect(joining(&quot;] + Kandidierende[&quot;, &quot;Kandidierende[&quot;, &quot;]&quot;)));</span>
			// Sainte-Laguë-Wert
<span class="nc" id="L589">			appendCell(row, party, Optional.of(dataFormatSainteLague), MetricsFileWriter::setCellValue, nominationResult.getSainteLagueValue());</span>
			// Mandat
<span class="nc" id="L591">			appendString(row, party, getDisplayValue(nominationResult.getType()));</span>
<span class="nc" id="L592">		}</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private MetricsFiles() {
		throw new java.lang.UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>