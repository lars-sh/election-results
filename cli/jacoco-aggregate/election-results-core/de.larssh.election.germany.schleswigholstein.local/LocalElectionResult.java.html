<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LocalElectionResult.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Election Results CLI</a> &gt; <a href="../index.html" class="el_bundle">election-results-core</a> &gt; <a href="index.source.html" class="el_package">de.larssh.election.germany.schleswigholstein.local</a> &gt; <span class="el_source">LocalElectionResult.java</span></div><h1>LocalElectionResult.java</h1><pre class="source lang-java linenums">// Generated by delombok at Fri Feb 24 17:02:43 UTC 2023
package de.larssh.election.germany.schleswigholstein.local;

import static de.larssh.utils.Collectors.toLinkedHashMap;
import static de.larssh.utils.Collectors.toLinkedHashSet;
import static de.larssh.utils.Collectors.toMap;
import static java.util.Collections.emptyMap;
import static java.util.Collections.emptySet;
import static java.util.Collections.unmodifiableList;
import static java.util.Collections.unmodifiableMap;
import static java.util.Collections.unmodifiableSet;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonCreator.Mode;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonProperty.Access;
import com.fasterxml.jackson.databind.ObjectWriter;
import de.larssh.election.germany.schleswigholstein.Ballot;
import de.larssh.election.germany.schleswigholstein.District;
import de.larssh.election.germany.schleswigholstein.DistrictValueMap;
import de.larssh.election.germany.schleswigholstein.ElectionException;
import de.larssh.election.germany.schleswigholstein.ElectionResult;
import de.larssh.election.germany.schleswigholstein.Nomination;
import de.larssh.election.germany.schleswigholstein.Party;
import de.larssh.election.germany.schleswigholstein.PartyResult;
import de.larssh.election.utils.BigDecimals;
import de.larssh.utils.Nullables;
import de.larssh.utils.OptionalInts;
import de.larssh.utils.Optionals;
import de.larssh.utils.annotations.PackagePrivate;
import de.larssh.utils.collection.Maps;
import de.larssh.utils.text.Strings;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * Wahlergebnis auf Basis einer ggf. gefilterten Liste an Stimmzetteln
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.DataClass&quot;, &quot;PMD.ExcessiveImports&quot;, &quot;PMD.GodClass&quot;})
public final class LocalElectionResult implements ElectionResult&lt;LocalBallot, LocalNomination&gt; {
	/**
	 * Thread-local temporary storage of a {@link LocalElection}, used while parsing
	 * JSON data.
	 *
	 * &lt;p&gt;
	 * This thread-local variable is empty and must not be set outside of
	 * {@link #fromJson(Reader, LocalElection)}.
	 */
	@PackagePrivate
<span class="fc" id="L70">	static final ThreadLocal&lt;LocalElection&gt; ELECTION_FOR_JSON_CREATOR = ThreadLocal.withInitial(() -&gt; {</span>
<span class="nc" id="L71">		throw new ElectionException(&quot;Cannot initialize electionForJsonCreator. Use LocalElection.fromJson(...) instead.&quot;);</span>
	});
	/**
	 * Comparator by value (high to low) and nomination
	 */
<span class="fc" id="L76">	private static final Comparator&lt;Entry&lt;LocalNomination, Integer&gt;&gt; VOTES_OF_NOMINATIONS_COMPARATOR = Comparator.&lt;Entry&lt;LocalNomination, Integer&gt;, Integer&gt;comparing(Entry::getValue).reversed().thenComparing(Entry::getKey);</span>

	/**
	 * Creates a new JSON {@link ObjectWriter} compatible with
	 * {@link LocalElectionResult}.
	 *
	 * @return the created JSON {@link ObjectWriter}
	 */
	public static ObjectWriter createJacksonObjectWriter() {
<span class="nc" id="L85">		return LocalElection.createJacksonObjectWriter();</span>
	}

	/**
	 * Creates a {@link LocalElectionResult} from JSON.
	 *
	 * @param reader   JSON data
	 * @param election Wahl
	 * @return the created {@link LocalElectionResult}
	 * @throws IOException on IO error
	 */
	public static LocalElectionResult fromJson(final Reader reader, final LocalElection election) throws IOException {
		try {
<span class="fc" id="L98">			ELECTION_FOR_JSON_CREATOR.set(election);</span>
<span class="fc" id="L99">			return LocalElection.OBJECT_MAPPER.readValue(reader, LocalElectionResult.class);</span>
		} finally {
<span class="fc" id="L101">			ELECTION_FOR_JSON_CREATOR.remove();</span>
		}
	}

	/**
	 * Wahl
	 */
	@JsonIgnore
	private final LocalElection election;
	/**
	 * Scale (decimal places) of Sainte Laguë values
	 *
	 * &lt;p&gt;
	 * Usually this is {@code 2}.
	 */
	@JsonProperty(access = Access.READ_ONLY, index = 0)
	private final int sainteLagueScale;
	/**
	 * Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
	 *
	 * &lt;p&gt;
	 * In case this number is larger than the size of the list of ballots for the
	 * district, not all ballots were evaluated, yet.
	 */
	@JsonProperty(access = Access.READ_ONLY, index = 1)
	private final DistrictValueMap numberOfAllBallots;
	/**
	 * Ausgeloste Loskandidaten mit Direktmandat
	 */
	private final Set&lt;LocalNomination&gt; directDrawResults;
	/**
	 * Ausgeloste Loskandidaten mit Listenmandat
	 */
	private final Set&lt;LocalNomination&gt; listDrawResults;
	/**
	 * Stimmzettel
	 */
	private final List&lt;LocalBallot&gt; ballots;
	/**
	 * Wahlergebnis einzelner Bewerberinnen und Bewerber
	 */
	@JsonIgnore
	private final Map&lt;LocalNomination, LocalNominationResult&gt; nominationResults;
	/**
	 * Wahlergebnis einzelner politischer Parteien und Wählergruppen
	 */
	@JsonIgnore
	private final Map&lt;Party, LocalPartyResult&gt; partyResults;

	/**
	 * Wahlergebnis
	 *
	 * @param parsable JSON delegate
	 */
	@JsonCreator(mode = Mode.DELEGATING)
	private LocalElectionResult(final ParsableLocalElectionResult parsable) {
<span class="fc" id="L157">		this(ELECTION_FOR_JSON_CREATOR.get(), parsable.getSainteLagueScale(), parsable.getNumberOfAllBallots(), parsable.getDirectDrawResults(), parsable.getListDrawResults(), parsable.getLocalBallots());</span>
<span class="fc" id="L158">	}</span>

	/**
	 * Wahlergebnis
	 *
	 * @param election           Wahl
	 * @param sainteLagueScale   Scale (decimal places) of Sainte Laguë values
	 * @param numberOfAllBallots optional number of all ballots of the election
	 * @param directDrawResults  Ausgeloste Loskandidaten mit Direktmandat
	 * @param listDrawResults    Ausgeloste Loskandidaten mit Listenmandat
	 * @param ballots            Stimmzettel
	 */
	@SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;Election is no longer modifiable when passed here.&quot;)
<span class="fc" id="L171">	public LocalElectionResult(final LocalElection election, final int sainteLagueScale, final Map&lt;District&lt;?&gt;, OptionalInt&gt; numberOfAllBallots, final Set&lt;LocalNomination&gt; directDrawResults, final Set&lt;LocalNomination&gt; listDrawResults, final List&lt;LocalBallot&gt; ballots) {</span>
<span class="fc" id="L172">		this.election = election;</span>
<span class="fc" id="L173">		this.sainteLagueScale = sainteLagueScale;</span>
<span class="fc" id="L174">		this.directDrawResults = unmodifiableSet(new LinkedHashSet&lt;&gt;(directDrawResults));</span>
<span class="fc" id="L175">		this.listDrawResults = unmodifiableSet(new LinkedHashSet&lt;&gt;(listDrawResults));</span>
<span class="fc" id="L176">		this.ballots = unmodifiableList(ballots);</span>
<span class="fc" id="L177">		this.numberOfAllBallots = new DistrictValueMap(election);</span>
<span class="fc" id="L178">		this.numberOfAllBallots.putAll(numberOfAllBallots);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		for (final LocalBallot ballot : ballots) {</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">			if (!ballot.getElection().equals(election)) {</span>
<span class="nc" id="L181">				throw new ElectionException(&quot;Election \&quot;%s\&quot; of ballot does not match given election \&quot;%s\&quot;.&quot;, ballot.getElection().getName(), election.getName());</span>
			}
<span class="fc" id="L183">		}</span>
		// Creating the nomination results first, because party results are based on the
		// nomination results
<span class="fc" id="L186">		nominationResults = unmodifiableMap(createNominationResults());</span>
<span class="fc" id="L187">		partyResults = unmodifiableMap(createPartyResults());</span>
<span class="fc" id="L188">	}</span>

	/**
	 * Creates a new {@link LocalElectionResult} by merging {@code this} and
	 * multiple {@code results} of the same election.
	 *
	 * @param resultsToAdd results to merge with {@code this}
	 * @return a new result object with the information of {@code this} and all
	 *         {@code resultsToAdd}
	 */
	public LocalElectionResult add(final LocalElectionResult... resultsToAdd) {
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">		if (!Arrays.stream(resultsToAdd).allMatch(result -&gt; result.getElection() == getElection())) {</span>
<span class="nc" id="L200">			throw new IllegalArgumentException(&quot;Election results of a different election cannot be merged.&quot;);</span>
		}
		// Create a new set including this
<span class="fc" id="L203">		final Set&lt;LocalElectionResult&gt; results = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L204">		results.add(this);</span>
<span class="fc" id="L205">		results.addAll(Arrays.asList(resultsToAdd));</span>
		// Calculate number of all ballots
<span class="fc" id="L207">		final Map&lt;District&lt;?&gt;, OptionalInt&gt; numberOfAllBallots = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">		for (final District&lt;?&gt; district : getElection().getAllDistricts()) {</span>
<span class="fc" id="L209">			Optionals.ofSingle(results.stream().map(result -&gt; result.getNumberOfAllBallots(district)).filter(OptionalInt::isPresent).distinct()).ifPresent(value -&gt; numberOfAllBallots.put(district, value));</span>
<span class="fc" id="L210">		}</span>
<span class="fc" id="L211">		final Set&lt;LocalNomination&gt; directDrawResults = results.stream().map(LocalElectionResult::getDirectDrawResults).flatMap(Collection::stream).collect(toSet());</span>
<span class="fc" id="L212">		final Set&lt;LocalNomination&gt; listDrawResults = results.stream().map(LocalElectionResult::getListDrawResults).flatMap(Collection::stream).collect(toSet());</span>
<span class="fc" id="L213">		final List&lt;LocalBallot&gt; ballots = results.stream().map(LocalElectionResult::getBallots).flatMap(Collection::stream).collect(toList());</span>
<span class="fc" id="L214">		return new LocalElectionResult(getElection(), sainteLagueScale, numberOfAllBallots, directDrawResults, listDrawResults, ballots);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public LocalElectionResult filter(final Predicate&lt;? super LocalBallot&gt; filter) {
<span class="nc" id="L222">		final List&lt;LocalBallot&gt; filteredBallots = getBallots().stream().filter(filter).collect(toList());</span>
<span class="nc" id="L223">		return new LocalElectionResult(getElection(), sainteLagueScale, emptyMap(), getDirectDrawResults(), getListDrawResults(), filteredBallots);</span>
	}

	/**
	 * Filters the current list of ballots by {@code district} and returns a new
	 * {@link ElectionResult}
	 *
	 * @param district the district to filter for
	 * @return a new {@link ElectionResult} with filtered ballots
	 */
	public LocalElectionResult filterByDistrict(final District&lt;?&gt; district) {
<span class="fc" id="L234">		final Map&lt;District&lt;?&gt;, OptionalInt&gt; filteredNumberOfAllBallots = numberOfAllBallots.entrySet().stream().filter(entry -&gt; district.contains(entry.getKey())).collect(toMap(HashMap::new));</span>
<span class="fc" id="L235">		return new LocalElectionResult(getElection(), sainteLagueScale, filteredNumberOfAllBallots, getDirectDrawResults(), getListDrawResults(), getBallots(district));</span>
	}

	/**
	 * Stimmzettel eines Wahlgebiets, Wahlkreises oder Wahlbezirks
	 *
	 * @param district the district to filter for
	 * @return Stimmzettel
	 */
	public List&lt;LocalBallot&gt; getBallots(final District&lt;?&gt; district) {
<span class="fc" id="L245">		return ballots.stream().filter(ballot -&gt; district.contains(ballot.getPollingStation())).collect(toList());</span>
	}

	/**
	 * Stimmzettel
	 *
	 * @return Stimmzettel
	 */
	private List&lt;LocalBallot&gt; getBallotsForEqualsAndHashCode() {
<span class="fc" id="L254">		return ballots.stream().sorted().collect(toList());</span>
	}

	/**
	 * Calculates the ballot evaluation progress in percentage.
	 *
	 * @param scale the scale of the {@link BigDecimal} quotient
	 * @return the ballot evaluation progress in percentage or empty if the number
	 *         of all ballots is empty
	 */
	public Optional&lt;BigDecimal&gt; getEvaluationProgress(final int scale) {
<span class="fc" id="L265">		return getEvaluationProgress(scale, getElection().getDistrict());</span>
	}

	/**
	 * Calculates the ballot evaluation progress of any district in percentage.
	 *
	 * @param scale    the scale of the {@link BigDecimal} quotient
	 * @param district the district to filter for
	 * @return the ballot evaluation progress in percentage or empty if the number
	 *         of all ballots is empty
	 */
	@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
	public Optional&lt;BigDecimal&gt; getEvaluationProgress(final int scale, final District&lt;?&gt; district) {
<span class="fc" id="L278">		return OptionalInts.mapToObj(getNumberOfAllBallots(district), numberOfAllBallots -&gt; BigDecimals.divideOrZero(100L * getBallots(district).size(), numberOfAllBallots, scale));</span>
	}

	/**
	 * Ausgeloste Loskandidaten mit Direktmandat eines Wahlkreises
	 *
	 * @param district Wahlkreis
	 * @return Ausgeloste Loskandidaten mit Direktmandat eines Wahlkreises
	 */
	@JsonIgnore
	public Set&lt;LocalNomination&gt; getDirectDrawResults(final LocalDistrict district) {
<span class="fc" id="L289">		return getDirectDrawResults().stream().filter(nomination -&gt; nomination.getDistrict().equals(district)).collect(toSet());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public OptionalInt getNumberOfAllBallots() {
<span class="fc" id="L297">		return getNumberOfAllBallots(getElection().getDistrict());</span>
	}

	/**
	 * Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
	 *
	 * &lt;p&gt;
	 * In case this number is larger than the size of the list of ballots for the
	 * district, not all ballots were evaluated, yet.
	 *
	 * @param district Wahlgebiet, Wahlkreis oder Wahlbezirk
	 * @return Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
	 */
	public OptionalInt getNumberOfAllBallots(final District&lt;?&gt; district) {
<span class="fc" id="L311">		final OptionalInt value = numberOfAllBallots.get(district);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">		return value.isPresent() ? OptionalInt.of(Math.max(value.getAsInt(), getBallots(district).size())) : value;</span>
	}

	/**
	 * Number of invalid ballots
	 *
	 * @return the number of invalid ballots
	 */
	@JsonIgnore
	public int getNumberOfInvalidBallots() {
<span class="fc" id="L322">		return getNumberOfInvalidBallots(getElection().getDistrict());</span>
	}

	/**
	 * Anzahl ungültiger Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
	 *
	 * @param district Wahlgebiet, Wahlkreis oder Wahlbezirk
	 * @return the number of invalid ballots
	 */
	public int getNumberOfInvalidBallots(final District&lt;?&gt; district) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">		return (int) getBallots(district).stream().filter(ballot -&gt; !ballot.isValid()).count();</span>
	}

	/**
	 * Number of postal ballots
	 *
	 * @return the number of postal ballots
	 */
	@JsonIgnore
	public int getNumberOfPostalBallots() {
<span class="fc" id="L342">		return (int) getBallots().stream().filter(LocalBallot::isPostalVote).count();</span>
	}

	/**
	 * Number of votes
	 *
	 * @return the number of votes
	 */
	@JsonIgnore
	public int getNumberOfVotes() {
<span class="nc" id="L352">		return getNumberOfVotes(getElection().getDistrict());</span>
	}

	/**
	 * Anzahl der Stimmen nach Wahlgebiet, Wahlkreis oder Wahlbezirk
	 *
	 * @param district Wahlgebiet, Wahlkreis oder Wahlbezirk
	 * @return the number of votes
	 */
	public int getNumberOfVotes(final District&lt;?&gt; district) {
<span class="fc" id="L362">		return getBallots(district).stream().filter(LocalBallot::isValid).map(LocalBallot::getNominations).mapToInt(Set::size).sum();</span>
	}

	/**
	 * Calculates the nomination results.
	 *
	 * &lt;p&gt;
	 * This method is used within the method constructor. Except for the balance
	 * seats the implementation is structured based on the order of
	 * {@link LocalNominationResultType}.
	 *
	 * @return Wahlergebnis einzelner Bewerberinnen und Bewerber
	 */
	private Map&lt;LocalNomination, LocalNominationResult&gt; createNominationResults() {
<span class="fc" id="L376">		final Map&lt;LocalNomination, Integer&gt; votes = getVotesOfNominations();</span>
<span class="fc" id="L377">		final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes = new LinkedHashMap&lt;&gt;(getElection().getNominations().size());</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">		for (final LocalDistrict district : getElection().getDistrict().getChildren()) {</span>
<span class="fc" id="L379">			final Map&lt;LocalNomination, Integer&gt; localVotes = votes.entrySet().stream().filter(entry -&gt; entry.getKey().getDistrict().equals(district)).collect(toLinkedHashMap());</span>
			// Result Type: Direct
<span class="fc" id="L381">			final Map&lt;LocalNomination, LocalNominationResultType&gt; localResultTypes = getDirectResults(localVotes).stream().collect(toLinkedHashMap(identity(), nomination -&gt; LocalNominationResultType.DIRECT));</span>
			// Result Type: Direct Draw
<span class="fc" id="L383">			putDrawNominations(localResultTypes, localVotes, getDirectDrawResults(district), LocalNominationResultType.DIRECT, LocalNominationResultType.DIRECT_DRAW);</span>
<span class="fc" id="L384">			resultTypes.putAll(localResultTypes);</span>
<span class="fc" id="L385">		}</span>
		// Result Type: Direct Balance Seat
<span class="fc" id="L387">		final Map&lt;LocalNomination, BigDecimal&gt; sainteLague = getSainteLague(votes);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">		for (final LocalNomination nomination : getBalanceSeats(resultTypes, sainteLague)) {</span>
<span class="fc" id="L389">			resultTypes.put(nomination, LocalNominationResultType.DIRECT_BALANCE_SEAT);</span>
<span class="fc" id="L390">		}</span>
		// Result Type: List
<span class="fc bfc" id="L392" title="All 2 branches covered.">		for (final LocalNomination nomination : getListResults(votes, sainteLague)) {</span>
<span class="fc" id="L393">			resultTypes.putIfAbsent(nomination, LocalNominationResultType.LIST);</span>
<span class="fc" id="L394">		}</span>
		// Result Type: List Draw
<span class="fc" id="L396">		putDrawNominations(resultTypes, sainteLague, getListDrawResults(), LocalNominationResultType.LIST, LocalNominationResultType.LIST_DRAW);</span>
		// Result Type: List Overhang Seat
<span class="fc bfc" id="L398" title="All 2 branches covered.">		for (final LocalNomination nomination : getOverhangSeats(resultTypes, votes, sainteLague)) {</span>
<span class="fc" id="L399">			resultTypes.put(nomination, LocalNominationResultType.LIST_OVERHANG_SEAT);</span>
<span class="fc" id="L400">		}</span>
		// Result Type: Not Elected
<span class="fc" id="L402">		return getElection().getNominations().stream().map(nomination -&gt; new LocalNominationResult(this, nomination, resultTypes.getOrDefault(nomination, LocalNominationResultType.NOT_ELECTED), Optional.ofNullable(sainteLague.get(nomination)))).sorted().collect(toLinkedHashMap(LocalNominationResult::getNomination, identity()));</span>
	}

	/**
	 * Calculates the number of votes per nomination. The returned map is sorted by
	 * value (high to low) and nomination. Nominations, which were not voted for are
	 * not part of the result.
	 *
	 * @return the number of votes per nomination
	 */
	private Map&lt;LocalNomination, Integer&gt; getVotesOfNominations() {
		// Calculate
<span class="fc" id="L414">		final Map&lt;LocalNomination, Integer&gt; votes = getBallots().stream().filter(Ballot::isValid).map(LocalBallot::getNominations).flatMap(Set::stream).collect(toMap(identity(), nomination -&gt; 1, (oldValue, thisValue) -&gt; oldValue + thisValue));</span>
		// Sort
<span class="fc" id="L416">		return Maps.sort(votes, VOTES_OF_NOMINATIONS_COMPARATOR);</span>
	}

	/**
	 * Calculates the number of votes per party. The returned map is sorted by value
	 * (low to high) and party. Parties, which were not voted for are not part of
	 * the result.
	 *
	 * @return the number of votes per party
	 */
	private Map&lt;Party, Integer&gt; getVotesOfParties() {
<span class="fc" id="L427">		return getBallots().stream().filter(Ballot::isValid).map(Ballot::getNominations).flatMap(Set::stream).map(Nomination::getParty).filter(Optional::isPresent).map(Optional::get).collect(toMap(identity(), party -&gt; 1, (oldValue, thisValue) -&gt; oldValue + thisValue));</span>
	}

	/**
	 * Calculates the Sainte Laguë value for each nomination.
	 *
	 * &lt;p&gt;
	 * The returned map is ordered by Sainte Laguë value (high to low), the number
	 * of votes (high to lower) and the nomination key.
	 *
	 * @param votes the number of votes per nomination
	 * @return the Sainte Laguë value for each nomination
	 */
	private Map&lt;LocalNomination, BigDecimal&gt; getSainteLague(final Map&lt;LocalNomination, Integer&gt; votes) {
		// Calculate
<span class="fc" id="L442">		final Map&lt;LocalNomination, BigDecimal&gt; sainteLague = getVotesOfParties().entrySet().stream().map(entry -&gt; getSainteLagueOfParty(votes, entry.getKey(), entry.getValue())).map(Map::entrySet).flatMap(Set::stream).collect(toLinkedHashMap());</span>
		// Sort
<span class="fc" id="L444">		final List&lt;LocalNomination&gt; nominations = getElection().getNominations();</span>
<span class="fc" id="L445">		return Maps.sort(sainteLague, Comparator.&lt;Entry&lt;LocalNomination, BigDecimal&gt;, BigDecimal&gt;comparing(Entry::getValue).thenComparing(entry -&gt; votes.getOrDefault(entry.getKey(), 0)).reversed().thenComparing(entry -&gt; nominations.indexOf(entry.getKey())));</span>
	}

	/**
	 * Calculates the Sainte Laguë value for each nomination of {@code party}.
	 *
	 * &lt;p&gt;
	 * The returned map is ordered by Sainte Laguë value (high to low).
	 *
	 * @param votes        the number of votes per nomination
	 * @param party        the party
	 * @param votesOfParty the number of votes for {@code party}
	 * @return the Sainte Laguë value for each nomination of {@code party}
	 */
	private Map&lt;LocalNomination, BigDecimal&gt; getSainteLagueOfParty(final Map&lt;LocalNomination, Integer&gt; votes, final Party party, final int votesOfParty) {
<span class="fc" id="L460">		final Set&lt;LocalNomination&gt; nominationsOfParty = getSainteLagueNominationsOfParty(votes, party);</span>
<span class="fc" id="L461">		final Iterator&lt;LocalNomination&gt; iterator = nominationsOfParty.iterator();</span>
<span class="fc" id="L462">		return IntStream.range(0, nominationsOfParty.size()).mapToObj(step -&gt; getSainteLagueValue(votesOfParty, step)).collect(toLinkedHashMap(step -&gt; iterator.next(), identity()));</span>
	}

	/**
	 * Returns a set of all nominations of {@code party} in their order of Sainte
	 * Laguë value assignment.
	 *
	 * &lt;p&gt;
	 * Directly elected nominations of {@code party} come first in order of their
	 * number of votes (high to low). All other nominations of {@code party} follow
	 * in given order.
	 *
	 * @param votes the number of votes per nomination
	 * @param party the party
	 * @return the nominations of {@code party} in their order of Sainte Laguë value
	 *         assignment
	 */
	private Set&lt;LocalNomination&gt; getSainteLagueNominationsOfParty(final Map&lt;LocalNomination, Integer&gt; votes, final Party party) {
<span class="fc" id="L480">		final Set&lt;LocalNomination&gt; nominations = new LinkedHashSet&lt;&gt;();</span>
		// Result Type: Direct and Direct Draw
<span class="fc" id="L482">		getDirectResults(votes).stream().filter(nomination -&gt; nomination.getParty().map(party::equals).orElse(Boolean.FALSE)).forEach(nominations::add);</span>
		// others
<span class="fc" id="L484">		nominations.addAll(getElection().getNominations(party));</span>
<span class="fc" id="L485">		return nominations;</span>
	}

	/**
	 * Calculates the Sainte Laguë value using the formula:
	 *
	 * &lt;p&gt;
	 * {@code votesOfParty / (step + 0.5)}
	 *
	 * &lt;p&gt;
	 * {@code step} starts at zero and the scale of the returned {@link BigDecimal}
	 * is given by {@link LocalElection#getSainteLagueScale()}.
	 *
	 * @param votesOfParty the number of votes of the corresponding party
	 * @param step         step, starting at zero
	 * @return the Sainte Laguë value
	 */
	@SuppressWarnings(&quot;checkstyle:MagicNumber&quot;)
	private BigDecimal getSainteLagueValue(final int votesOfParty, final int step) {
<span class="fc" id="L504">		return BigDecimals.divide(votesOfParty, BigDecimal.valueOf(step * 10 + 5, 1), getSainteLagueScale());</span>
	}

	/**
	 * Returns a set of nominations, which were elected directly.
	 *
	 * &lt;p&gt;
	 * Implementation notice: This method simply returns the best few nominations
	 * based on {@link LocalElection#getNumberOfDirectSeatsPerLocalDistrict()}.
	 * Therefore there is a chance, that some of the returned nominations need to
	 * turn into direct draw candidates.
	 *
	 * @param votes the number of votes per nomination
	 * @return the directly elected nominations
	 */
	private Set&lt;LocalNomination&gt; getDirectResults(final Map&lt;LocalNomination, Integer&gt; votes) {
<span class="fc" id="L520">		return votes.keySet().stream().limit(getElection().getNumberOfDirectSeatsPerLocalDistrict()).collect(toLinkedHashSet());</span>
	}

	/**
	 * Puts nominations with either draw results or open draws to
	 * {@code resultTypes}.
	 *
	 * &lt;p&gt;
	 * The number of votes of a draw are given by the last nomination of
	 * {@code resultTypes} and the number of maximum possible seats is given by the
	 * size of {@code resultTypes}.
	 *
	 * &lt;p&gt;
	 * {@code drawResults} must neither contain more nominations than possible draw
	 * seats, nor invalid nominations. In addition it does not need to contain a
	 * draw result for all open draws or even any draw result. In such cases one of
	 * the draw {@link LocalNominationResultType} is put to {@code resultTypes}
	 * according to {@code currentResultTypeDraw}.
	 *
	 * @param resultTypes           result types per nomination
	 * @param votes                 the number of votes per nomination
	 * @param drawResults           optional draws results to take into account
	 * @param currentResultType     the original result type, which might need draws
	 * @param currentResultTypeDraw the corresponding draw result type
	 */
	private void putDrawNominations(final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes, final Map&lt;LocalNomination, ? extends Number&gt; votes, final Set&lt;LocalNomination&gt; drawResults, final LocalNominationResultType currentResultType, final LocalNominationResultType currentResultTypeDraw) {
<span class="fc" id="L546">		final Optional&lt;LocalNomination&gt; lastNomination = resultTypes.keySet().stream().reduce((first, second) -&gt; second);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">		if (!lastNomination.isPresent()) {</span>
<span class="fc" id="L548">			return;</span>
		}
<span class="fc" id="L550">		final Number votesForLastNomination = votes.get(lastNomination.get());</span>
<span class="fc" id="L551">		final int numberOfPossibleSeats = resultTypes.size();</span>
		// Remove the last few entries, which have the same result type and votes
<span class="fc bfc" id="L553" title="All 4 branches covered.">		resultTypes.entrySet().removeIf(entry -&gt; entry.getValue() == currentResultType &amp;&amp; votes.get(entry.getKey()).equals(votesForLastNomination));</span>
<span class="fc" id="L554">		final int numberOfDrawSeats = numberOfPossibleSeats - resultTypes.size();</span>
		// Add positive draw results
<span class="fc" id="L556">		validateDrawResults(resultTypes, votes, votesForLastNomination, numberOfDrawSeats, drawResults, currentResultType);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">		for (final LocalNomination drawResult : drawResults) {</span>
<span class="fc" id="L558">			resultTypes.put(drawResult, currentResultType);</span>
<span class="fc" id="L559">		}</span>
		// Add open draws
<span class="fc" id="L561">		final Set&lt;LocalNomination&gt; drawNominations = getDrawNominations(resultTypes, votes, votesForLastNomination, numberOfDrawSeats, drawResults, currentResultType);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">		final LocalNominationResultType drawResultType = drawNominations.size() &gt; numberOfDrawSeats ? currentResultTypeDraw : currentResultType;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">		for (final LocalNomination nomination : drawNominations) {</span>
<span class="fc" id="L564">			resultTypes.putIfAbsent(nomination, drawResultType);</span>
<span class="fc" id="L565">		}</span>
<span class="fc" id="L566">	}</span>

	/**
	 * Validates {@code drawResults}.
	 *
	 * &lt;p&gt;
	 * Right now the number of draw results must not be larger than the number of
	 * draw seats. In addition each nomination must be part of the draw by number of
	 * votes and result type.
	 *
	 * @param resultTypes            result types per nomination
	 * @param votes                  the number of votes per nomination
	 * @param votesForLastNomination the number of votes for nominations of the draw
	 * @param numberOfDrawSeats      the number of draw seats
	 * @param drawResults            optional draws results to take into account
	 * @param currentResultType      the original result type, which might need
	 *                               draws
	 */
	private void validateDrawResults(final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes, final Map&lt;LocalNomination, ? extends Number&gt; votes, final Number votesForLastNomination, final int numberOfDrawSeats, final Set&lt;LocalNomination&gt; drawResults, final LocalNominationResultType currentResultType) {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">		if (drawResults.size() &gt; numberOfDrawSeats) {</span>
<span class="nc" id="L586">			throw new ElectionException(&quot;%d %s draw results given while expecting %d %s draw results at max.&quot;, drawResults.size(), Strings.toLowerCaseNeutral(currentResultType.toString()), numberOfDrawSeats, Strings.toLowerCaseNeutral(currentResultType.toString()));</span>
		}
<span class="fc bfc" id="L588" title="All 2 branches covered.">		for (final LocalNomination nomination : drawResults) {</span>
<span class="pc bpc" id="L589" title="2 of 4 branches missed.">			if (!Nullables.orElse(votes.get(nomination), 0).equals(votesForLastNomination) || resultTypes.getOrDefault(nomination, currentResultType) != currentResultType) {</span>
<span class="nc" id="L590">				throw new ElectionException(&quot;\&quot;%s\&quot; is not part of the %s draw.&quot;, nomination.getPerson().getKey(), Strings.toLowerCaseNeutral(currentResultType.toString()));</span>
			}
<span class="fc" id="L592">		}</span>
<span class="fc" id="L593">	}</span>

	/**
	 * Returns the nominations, which are part of the draw.
	 *
	 * @param resultTypes            result types per nomination
	 * @param votes                  the number of votes per nomination
	 * @param votesForLastNomination the number of votes for nominations of the draw
	 * @param numberOfDrawSeats      the number of draw seats
	 * @param drawResults            optional draws results to take into account
	 * @param currentResultType      the original result type, which might need
	 *                               draws
	 * @return the nominations, which are part of the draw
	 */
	private Set&lt;LocalNomination&gt; getDrawNominations(final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes, final Map&lt;LocalNomination, ? extends Number&gt; votes, final Number votesForLastNomination, final int numberOfDrawSeats, final Set&lt;LocalNomination&gt; drawResults, final LocalNominationResultType currentResultType) {
		// No need to iterate &quot;votes&quot; if all draw seats are filled with draw results.
<span class="fc bfc" id="L609" title="All 2 branches covered.">		if (numberOfDrawSeats &lt;= drawResults.size()) {</span>
<span class="fc" id="L610">			return emptySet();</span>
		}
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">		return votes.entrySet().stream().filter(entry -&gt; entry.getValue().equals(votesForLastNomination)).map(Entry::getKey).filter(nomination -&gt; resultTypes.getOrDefault(nomination, currentResultType) == currentResultType).collect(toSet());</span>
	}

	/**
	 * Returns nominations, which have balance seats.
	 *
	 * @param resultTypes result types per nomination
	 * @param sainteLague the Sainte Laguë value per nomination
	 * @return the nominations, which have balance seats
	 */
	private Set&lt;LocalNomination&gt; getBalanceSeats(final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes, final Map&lt;LocalNomination, BigDecimal&gt; sainteLague) {
<span class="fc bfc" id="L623" title="All 2 branches covered.">		return sainteLague.keySet().stream().skip(getElection().getNumberOfSeats()).filter(nomination -&gt; resultTypes.get(nomination) == LocalNominationResultType.DIRECT).collect(toSet());</span>
	}

	/**
	 * Returns a set of nominations, which were elected by list.
	 *
	 * &lt;p&gt;
	 * Implementation notice: This method simply returns the best few nominations
	 * based on {@link LocalElection#getNumberOfSeats()}. Therefore there is a
	 * chance, that some of the returned nominations need to turn into list draw
	 * candidates.
	 *
	 * &lt;p&gt;
	 * In case some direct results have a relatively low Sainte Laguë value the
	 * returned map might be larger than {@link LocalElection#getNumberOfSeats()}.
	 *
	 * &lt;p&gt;
	 * The returned map is ordered the same as {@code sainteLague}.
	 *
	 * @param votes       the number of votes per nomination
	 * @param sainteLague the Sainte Laguë value per nomination
	 * @return the elected nominations by list
	 */
	private Set&lt;LocalNomination&gt; getListResults(final Map&lt;LocalNomination, Integer&gt; votes, final Map&lt;LocalNomination, BigDecimal&gt; sainteLague) {
<span class="fc" id="L647">		final Set&lt;LocalNomination&gt; directNominationsWithParty = getDirectResults(votes).stream().filter(nomination -&gt; nomination.getParty().isPresent()).collect(toSet());</span>
<span class="fc" id="L648">		final int numberOfSeats = getElection().getNumberOfSeats();</span>
<span class="fc" id="L649">		final Set&lt;LocalNomination&gt; nominations = new LinkedHashSet&lt;&gt;(numberOfSeats);</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">		for (final LocalNomination nomination : sainteLague.keySet()) {</span>
<span class="fc bfc" id="L651" title="All 4 branches covered.">			if (nominations.size() &gt;= numberOfSeats &amp;&amp; nominations.containsAll(directNominationsWithParty)) {</span>
<span class="fc" id="L652">				return nominations;</span>
			}
<span class="fc" id="L654">			nominations.add(nomination);</span>
<span class="fc" id="L655">		}</span>
<span class="fc" id="L656">		return nominations;</span>
	}

	/**
	 * Returns nominations, which have overhang seats.
	 *
	 * @param resultTypes result types per nomination
	 * @param votes       the number of votes per nomination
	 * @param sainteLague the Sainte Laguë value per nomination
	 * @return the nominations, which have overhang seats
	 */
	private Set&lt;LocalNomination&gt; getOverhangSeats(final Map&lt;LocalNomination, LocalNominationResultType&gt; resultTypes, final Map&lt;LocalNomination, Integer&gt; votes, final Map&lt;LocalNomination, BigDecimal&gt; sainteLague) {
<span class="fc bfc" id="L668" title="All 4 branches covered.">		return sainteLague.keySet().stream().filter(nomination -&gt; !getDirectResults(votes).contains(nomination)).skip(getElection().getNumberOfListSeats()).filter(nomination -&gt; resultTypes.get(nomination) == LocalNominationResultType.LIST).collect(toSet());</span>
	}

	/**
	 * Creates the party results.
	 *
	 * &lt;p&gt;
	 * This method is used within the method constructor. Calculating the results is
	 * done within {@link LocalPartyResult} and required the nomination results to
	 * be calculated beforehand.
	 *
	 * @return Wahlergebnis einzelner politischer Parteien und Wählergruppen
	 */
	private Map&lt;Party, LocalPartyResult&gt; createPartyResults() {
<span class="fc" id="L682">		return getElection().getParties().stream().map(party -&gt; new LocalPartyResult(this, party)).sorted().collect(toLinkedHashMap(PartyResult::getParty, identity()));</span>
	}


	/**
	 * JSON delegate for {@link LocalElectionResult}
	 */
	private static class ParsableLocalElectionResult {
		/**
		 * Finds a set of {@link LocalNomination}s by their keys.
		 *
		 * @param nominationKeys the keys to find
		 * @return a set of {@link LocalNomination}s, found by their keys
		 */
		public static Set&lt;LocalNomination&gt; findNominations(final Set&lt;String&gt; nominationKeys) {
<span class="fc" id="L697">			final LocalElection election = ELECTION_FOR_JSON_CREATOR.get();</span>
<span class="pc" id="L698">			return nominationKeys.stream().map(nominationKey -&gt; Optionals.ofSingle(election.getNominations().stream().filter(nomination -&gt; nomination.getKey().equals(nominationKey))).orElseThrow(() -&gt; new ElectionException(&quot;Could not find nomination with key \&quot;%s\&quot; for election \&quot;%s\&quot;.&quot;, nominationKey, election.getName()))).collect(toLinkedHashSet());</span>
		}

		/**
		 * Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
		 *
		 * &lt;p&gt;
		 * In case this number is larger than the size of the list of ballots for the
		 * district, not all ballots were evaluated, yet.
		 */
		private final Map&lt;String, OptionalInt&gt; numberOfAllBallots;
		/**
		 * Scale (decimal places) of Sainte Laguë values
		 *
		 * &lt;p&gt;
		 * Usually this is {@code 2}.
		 */
		private final int sainteLagueScale;
		/**
		 * Ausgeloste Loskandidaten mit Direktmandat
		 */
		private final Set&lt;String&gt; directDrawResults;
		/**
		 * Ausgeloste Loskandidaten mit Listenmandat
		 */
		private final Set&lt;String&gt; listDrawResults;
		/**
		 * Stimmzettel
		 */
		private final List&lt;ParsableLocalBallot&gt; ballots;

		/**
		 * Stimmzettel
		 *
		 * @return Stimmzettel
		 */
		public List&lt;LocalBallot&gt; getLocalBallots() {
<span class="fc" id="L735">			final LocalElection election = ELECTION_FOR_JSON_CREATOR.get();</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">			return ballots.stream().map(ballot -&gt; ballot.isValid() ? LocalBallot.createValidBallot(election, ballot.getPollingStation(), ballot.isPostalVote(), ballot.getNominations()) : LocalBallot.createInvalidBallot(election, ballot.getPollingStation(), ballot.isPostalVote())).collect(toList());</span>
		}

		/**
		 * Ausgeloste Loskandidaten mit Direktmandat
		 *
		 * @return Ausgeloste Loskandidaten mit Direktmandat
		 */
		public Set&lt;LocalNomination&gt; getDirectDrawResults() {
<span class="fc" id="L745">			return findNominations(directDrawResults);</span>
		}

		/**
		 * Ausgeloste Loskandidaten mit Listenmandat
		 *
		 * @return Ausgeloste Loskandidaten mit Listenmandat
		 */
		public Set&lt;LocalNomination&gt; getListDrawResults() {
<span class="fc" id="L754">			return findNominations(listDrawResults);</span>
		}

		/**
		 * Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
		 *
		 * &lt;p&gt;
		 * In case this number is larger than the size of the list of ballots for the
		 * district, not all ballots were evaluated, yet.
		 *
		 * @return Anzahl aller Stimmzettel nach Wahlgebiet, Wahlkreis oder Wahlbezirk
		 */
		public Map&lt;District&lt;?&gt;, OptionalInt&gt; getNumberOfAllBallots() {
<span class="fc" id="L767">			return ELECTION_FOR_JSON_CREATOR.get().getAllDistricts().stream().collect(toMap(identity(), district -&gt; numberOfAllBallots.getOrDefault(district.getKey(), OptionalInt.empty())));</span>
		}

		/**
		 * Scale (decimal places) of Sainte Laguë values
		 *
		 * &lt;p&gt;
		 * Usually this is {@code 2}.
		 *
		 * @return the scale (decimal places) of Sainte Laguë values
		 */
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public int getSainteLagueScale() {
			return this.sainteLagueScale;
		}

		/**
		 * Stimmzettel
		 */
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public List&lt;ParsableLocalBallot&gt; getBallots() {
			return this.ballots;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public ParsableLocalElectionResult(final Map&lt;String, OptionalInt&gt; numberOfAllBallots, final int sainteLagueScale, final Set&lt;String&gt; directDrawResults, final Set&lt;String&gt; listDrawResults, final List&lt;ParsableLocalBallot&gt; ballots) {
			this.numberOfAllBallots = numberOfAllBallots;
			this.sainteLagueScale = sainteLagueScale;
			this.directDrawResults = directDrawResults;
			this.listDrawResults = listDrawResults;
			this.ballots = ballots;
		}
	}


	/**
	 * JSON delegate for {@link LocalBallot}
	 */
	private static class ParsableLocalBallot {
		/**
		 * Wahlbezirk
		 */
		private final String pollingStation;
		/**
		 * Briefwahl
		 *
		 * @return {@code true} for postal vote ballots, else {@code false}
		 */
		private final boolean postalVote;
		/**
		 * Ungültige Stimme
		 *
		 * @return {@code true} for valid ballots, else {@code false}
		 */
		private final boolean valid;
		/**
		 * Gewählte Bewerberinnen und Bewerber
		 */
		private final Set&lt;String&gt; nominations;

		/**
		 * Wahlbezirk
		 *
		 * @return Wahlbezirk
		 */
		public LocalPollingStation getPollingStation() {
<span class="pc" id="L839">			return ELECTION_FOR_JSON_CREATOR.get().getPollingStations().stream().filter(district -&gt; pollingStation.equals(district.getKey())).findAny().orElseThrow(() -&gt; new ElectionException(&quot;Could not find polling station with key \&quot;%s\&quot; for election \&quot;%s\&quot;.&quot;, getPollingStation(), ELECTION_FOR_JSON_CREATOR.get().getName()));</span>
		}

		/**
		 * Gewählte Bewerberinnen und Bewerber
		 *
		 * @return Gewählte Bewerberinnen und Bewerber
		 */
		public Set&lt;LocalNomination&gt; getNominations() {
<span class="fc" id="L848">			return ParsableLocalElectionResult.findNominations(nominations);</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public boolean isPostalVote() {
			return this.postalVote;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public boolean isValid() {
			return this.valid;
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
		@lombok.Generated
		public ParsableLocalBallot(final String pollingStation, final boolean postalVote, final boolean valid, final Set&lt;String&gt; nominations) {
			this.pollingStation = pollingStation;
			this.postalVote = postalVote;
			this.valid = valid;
			this.nominations = nominations;
		}
	}

	/**
	 * Wahl
	 *
	 * @return Wahl
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public LocalElection getElection() {
		return this.election;
	}

	/**
	 * Scale (decimal places) of Sainte Laguë values
	 *
	 * &lt;p&gt;
	 * Usually this is {@code 2}.
	 *
	 * @return the scale (decimal places) of Sainte Laguë values
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int getSainteLagueScale() {
		return this.sainteLagueScale;
	}

	/**
	 * Ausgeloste Loskandidaten mit Direktmandat
	 *
	 * @return Ausgeloste Loskandidaten mit Direktmandat
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Set&lt;LocalNomination&gt; getDirectDrawResults() {
		return this.directDrawResults;
	}

	/**
	 * Ausgeloste Loskandidaten mit Listenmandat
	 *
	 * @return Ausgeloste Loskandidaten mit Listenmandat
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Set&lt;LocalNomination&gt; getListDrawResults() {
		return this.listDrawResults;
	}

	/**
	 * Stimmzettel
	 *
	 * @return Stimmzettel
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public List&lt;LocalBallot&gt; getBallots() {
		return this.ballots;
	}

	/**
	 * Wahlergebnis einzelner Bewerberinnen und Bewerber
	 *
	 * @return Wahlergebnis einzelner Bewerberinnen und Bewerber
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Map&lt;LocalNomination, LocalNominationResult&gt; getNominationResults() {
		return this.nominationResults;
	}

	/**
	 * Wahlergebnis einzelner politischer Parteien und Wählergruppen
	 *
	 * @return Wahlergebnis einzelner politischer Parteien und Wählergruppen
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public Map&lt;Party, LocalPartyResult&gt; getPartyResults() {
		return this.partyResults;
	}

	@edu.umd.cs.findbugs.annotations.NonNull
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public java.lang.String toString() {
		return &quot;LocalElectionResult(sainteLagueScale=&quot; + this.getSainteLagueScale() + &quot;)&quot;;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean equals(@edu.umd.cs.findbugs.annotations.Nullable final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof LocalElectionResult)) return false;
		final LocalElectionResult other = (LocalElectionResult) o;
		final java.lang.Object this$election = this.getElection();
		final java.lang.Object other$election = other.getElection();
		if (this$election == null ? other$election != null : !this$election.equals(other$election)) return false;
		final java.lang.Object this$numberOfAllBallots = this.getNumberOfAllBallots();
		final java.lang.Object other$numberOfAllBallots = other.getNumberOfAllBallots();
		if (this$numberOfAllBallots == null ? other$numberOfAllBallots != null : !this$numberOfAllBallots.equals(other$numberOfAllBallots)) return false;
		final java.lang.Object this$directDrawResults = this.getDirectDrawResults();
		final java.lang.Object other$directDrawResults = other.getDirectDrawResults();
		if (this$directDrawResults == null ? other$directDrawResults != null : !this$directDrawResults.equals(other$directDrawResults)) return false;
		final java.lang.Object this$listDrawResults = this.getListDrawResults();
		final java.lang.Object other$listDrawResults = other.getListDrawResults();
		if (this$listDrawResults == null ? other$listDrawResults != null : !this$listDrawResults.equals(other$listDrawResults)) return false;
		final java.lang.Object this$$getBallotsForEqualsAndHashCode = this.getBallotsForEqualsAndHashCode();
		final java.lang.Object other$$getBallotsForEqualsAndHashCode = other.getBallotsForEqualsAndHashCode();
		if (this$$getBallotsForEqualsAndHashCode == null ? other$$getBallotsForEqualsAndHashCode != null : !this$$getBallotsForEqualsAndHashCode.equals(other$$getBallotsForEqualsAndHashCode)) return false;
		return true;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		final java.lang.Object $election = this.getElection();
		result = result * PRIME + ($election == null ? 43 : $election.hashCode());
		final java.lang.Object $numberOfAllBallots = this.getNumberOfAllBallots();
		result = result * PRIME + ($numberOfAllBallots == null ? 43 : $numberOfAllBallots.hashCode());
		final java.lang.Object $directDrawResults = this.getDirectDrawResults();
		result = result * PRIME + ($directDrawResults == null ? 43 : $directDrawResults.hashCode());
		final java.lang.Object $listDrawResults = this.getListDrawResults();
		result = result * PRIME + ($listDrawResults == null ? 43 : $listDrawResults.hashCode());
		final java.lang.Object $$getBallotsForEqualsAndHashCode = this.getBallotsForEqualsAndHashCode();
		result = result * PRIME + ($$getBallotsForEqualsAndHashCode == null ? 43 : $$getBallotsForEqualsAndHashCode.hashCode());
		return result;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>